<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_terrainbox</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>moveh = 0;
movev = 0;

run_spd_max = 500;
run_acc_spd = 50;
run_deacc_rate = 0.1;
run_deacc_spd = 30;

ground_jump = 750;
ground_jump_xreduct = 0.1;

JumpsExtra = 1;
JumpsUsed = 0;

inp_YCrawlTreshold = 0.5;

crawl_spd_max = 100;
crawl_acc_spd = 70;
crawl_deacc_spd = 500;

slide_deacc_spd = 10;
slide_deacc_rate = 0.05;

air_spd_max = 300;
air_acc_spd = 15;
air_deacc_rate = 0.01;
air_deacc_spd = 2;

gravel = 15;//m/s^2
hover_speed = 200
fall_speed = 400 

///All Inputs is off 
inp_ymove = 0;
inp_xmove = 0;
/*********TEMPORARY CODE*********/
device = 0;
gamepad_set_axis_deadzone(device, 0.2);
state = states.Normal
place = places.Air
global.gap = 0;
/*********TEMPORARY CODE*********/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///The main mechanics with her0
var seconds_passed = delta_time/1000000;
var seconds_moveh = moveh/seconds_passed;

switch (state){

    case states.Stunned: {} break;
    /*****************************************************************************************************
    *****************************************************************************************************/
    
    case states.Attacking: {} break;
    /*****************************************************************************************************
    *****************************************************************************************************/
    
    case states.Normal: scr_input_shift(); scr_input_interpreter();{ 
    /*****************************************************************************************************
    *****************************************************************************************************/
        
        if place_meeting(x,y+1,obj_solid) {place = places.Ground; movev = 0;}
        else {place = places.Air;}

        switch (place)
        {
            case places.Ground: {
            /*****************/
            
                //Determing in what stance the hero is in and corrects y axis
                var scale = image_yscale;
                if inp_ymove &gt; inp_YCrawlTreshold {
                    if abs(seconds_moveh) &lt; crawl_spd_max {
                    stance = stances.Duck;
                    image_yscale = 0.5;
                    }
                    if abs(seconds_moveh) &gt; crawl_spd_max and stance != stances.Duck {
                    stance = stances.Slide;
                    image_yscale = 0.1;
                    }
                } else {
                    stance = stances.Stand;
                    image_yscale = 1;
                }
                var diff = ((scale - image_yscale) * sprite_height);
                if scale != image_yscale {
                    y+=diff;
                    scr_NoCollisionNoJump(ceil(abs(diff)));
                }
                
                switch (stance){
                
                    case stances.Duck: {
                    /***/
                    
                            ///Accelerate, Deaccelerate Crawling
                            moveh += scr_AccDeacc(seconds_moveh,crawl_spd_max,true,crawl_acc_spd,crawl_deacc_spd,inp_xmove,0) * seconds_passed;
                    
                            ///Jump
                            if inp_bpressed[3] and !place_meeting(x+moveh*ground_jump_xreduct,
                            y-ground_jump*seconds_passed,obj_solid){
                                moveh += moveh*ground_jump_xreduct;
                                movev -= ground_jump*seconds_passed; 
                                
                                var xtarg = x+moveh;
                                var ytarg = y+movev;
                                
                                x = xtarg;
                                y = ytarg;
                                
                                place = places.Air;
                                exit;
                            }
                    
                            scr_collision(places.Ground);
                        
                    } break;
                    
                    case stances.Slide: {
                    /***/
                    
                            ///Accelerate, Deaccelerate Crawling
                            moveh += scr_AccDeacc(seconds_moveh,0,false,0,slide_deacc_spd,0,slide_deacc_rate) * seconds_passed;
                            
                            scr_collision(places.Ground);
                            
                    } break;
                    
                    
                    case stances.Stand: {
                    /***/

                            ///Accelerate, Deaccelerate
                            moveh += scr_AccDeacc(seconds_moveh,run_spd_max,true,
                            run_acc_spd,run_deacc_spd,inp_xmove,run_deacc_rate) * seconds_passed;
                    
                            ///Jump
                            if inp_bpressed[3] and !place_meeting(x+moveh*ground_jump_xreduct,
                            y-ground_jump*seconds_passed,obj_solid){
                                moveh += moveh*ground_jump_xreduct;
                                movev -= ground_jump*seconds_passed; 
                                
                                var xtarg = x+moveh;
                                var ytarg = y+movev;
                                
                                x = xtarg;
                                y = ytarg;
                                
                                place = places.Air;
                                exit;
                            }
                    
                            scr_collision(places.Ground);
                    
                    } break;
                    
                } 

            } break;
            case places.Air: {
            /*****************/
            
                ///Fly left or right
                moveh += scr_AccDeacc(moveh/seconds_passed,air_spd_max,true,
                air_acc_spd,air_deacc_spd,inp_xmove,air_deacc_rate) * seconds_passed;
        
                ///Air Jump
                if inp_bpressed[3] and JumpsUsed++ &lt; JumpsExra
                {
                    
                }
                
                ///Fall
                movev += gravel*seconds_passed;
                if !inp_b[3] {
                    if movev &lt; 0 {movev = max(movev,-ground_jump/2*seconds_passed);}
                    if movev &gt; 10 { movev += gravel * seconds_passed;}
                } else {
                    movev = min(movev,hover_speed*seconds_passed);
                }
                if 2 &gt; movev and movev &gt; -2 { movev += gravel * seconds_passed;}
                
                scr_collision(places.Air);

            } break;
            
            case places.Wall: {} break;
            /*****************/
            case places.Edge: {} break;
            /*****************/
        }

    } break;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>500</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring>draw_self();</codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>515</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_draw_arrow</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>-1</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>inp_xmove*120</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>inp_ymove*120</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>12</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var yy
switch(place){
    case places.Ground: yy = "Ground"; break;
    case places.Air: yy = "Air"; break;
}
xx = string(moveh);
zz = string(movev);
rr = ","
draw_set_font(font0);
draw_text(x,y-50,yy);
draw_text(x-16,y-64,xx+rr+zz)
draw_text(x-8,y-80,string(global.gap));


        var xtarg = x+lengthdir_x(50, 90+ radtodeg(2*pi*inp_xattack));
        var ytarg = y+lengthdir_y(50, 90+ radtodeg(2*pi*inp_xattack));
        
        draw_circle(xtarg, ytarg, 10, true)

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
